#pragma once

// The following code is automatically generated by Hao & Yihe's parser/codegen
// Please do not manually modify!

// Definitions for row type: one_version_row
struct one_version_row {

    enum class NamedColumn : int { f1 = 0, f2, f3, f4, f5, f6, f7, f8 };

    int64_t f1;
    int64_t f2;
    int64_t f3;
    int64_t f4;
    int64_t f5;
    int64_t f6;
    int64_t f7;
    int64_t f8;
};


// Definitions for row type: two_version_row
struct two_version_row {

    enum class NamedColumn : int { f1 = 0, f2, f3, f4, f5, f6, f7, f8 };

    int64_t f1;
    int64_t f2;
    int64_t f3;
    int64_t f4;
    int64_t f5;
    int64_t f6;
    int64_t f7;
    int64_t f8;
};


// Definitions for row type: four_version_row
struct four_version_row {

    enum class NamedColumn : int { f1 = 0, f2, f3, f4, f5, f6, f7, f8 };

    int64_t f1;
    int64_t f2;
    int64_t f3;
    int64_t f4;
    int64_t f5;
    int64_t f6;
    int64_t f7;
    int64_t f8;
};


// Definitions for row type: eight_version_row
struct eight_version_row {

    enum class NamedColumn : int { f1 = 0, f2, f3, f4, f5, f6, f7, f8 };

    int64_t f1;
    int64_t f2;
    int64_t f3;
    int64_t f4;
    int64_t f5;
    int64_t f6;
    int64_t f7;
    int64_t f8;
};



namespace ver_sel {

template <typename VersImpl>
class VerSel<one_version_row, VersImpl> : public VerSelBase<VerSel<one_version_row, VersImpl>, VersImpl> {
public:
    typedef VersImpl version_type;
    static constexpr size_t num_versions = 1;

    explicit VerSel(type v) : vers_() { (void)v; }
    VerSel(type v, bool insert) : vers_() { (void)v; (void)insert; }

    static int map_impl(int col_n) {
        uint64_t mask = ~(~0ul << vidx_width) ;
        int shift = col_n * vidx_width;
        return ((col_cell_map & (mask << shift)) >> shift);
    }

    version_type& version_at_impl(int cell) {
        return vers_[cell];
    }

    void install_by_cell_impl(one_version_row *dst, const one_version_row *src, int cell) {
        switch (cell) {
        case 0:
            dst->f1 = src->f1;
            dst->f2 = src->f2;
            dst->f3 = src->f3;
            dst->f4 = src->f4;
            dst->f5 = src->f5;
            dst->f6 = src->f6;
            dst->f7 = src->f7;
            dst->f8 = src->f8;
            break;
        default:
            always_assert(false, "cell id out of bound\n");
            break;
        }
    }

private:
    version_type vers_[num_versions];
    static constexpr unsigned int vidx_width = 0u;
    static constexpr uint64_t col_cell_map = 0ul;
};


template <typename VersImpl>
class VerSel<two_version_row, VersImpl> : public VerSelBase<VerSel<two_version_row, VersImpl>, VersImpl> {
public:
    typedef VersImpl version_type;
    static constexpr size_t num_versions = 2;

    explicit VerSel(type v) : vers_() { (void)v; }
    VerSel(type v, bool insert) : vers_() { (void)v; (void)insert; }

    static int map_impl(int col_n) {
        uint64_t mask = ~(~0ul << vidx_width) ;
        int shift = col_n * vidx_width;
        return ((col_cell_map & (mask << shift)) >> shift);
    }

    version_type& version_at_impl(int cell) {
        return vers_[cell];
    }

    void install_by_cell_impl(two_version_row *dst, const two_version_row *src, int cell) {
        switch (cell) {
        case 0:
            dst->f1 = src->f1;
            dst->f2 = src->f2;
            dst->f3 = src->f3;
            dst->f4 = src->f4;
            break;
        case 1:
            dst->f5 = src->f5;
            dst->f6 = src->f6;
            dst->f7 = src->f7;
            dst->f8 = src->f8;
            break;
        default:
            always_assert(false, "cell id out of bound\n");
            break;
        }
    }

private:
    version_type vers_[num_versions];
    static constexpr unsigned int vidx_width = 1u;
    static constexpr uint64_t col_cell_map = 240ul;
};


template <typename VersImpl>
class VerSel<four_version_row, VersImpl> : public VerSelBase<VerSel<four_version_row, VersImpl>, VersImpl> {
public:
    typedef VersImpl version_type;
    static constexpr size_t num_versions = 4;

    explicit VerSel(type v) : vers_() { (void)v; }
    VerSel(type v, bool insert) : vers_() { (void)v; (void)insert; }

    static int map_impl(int col_n) {
        uint64_t mask = ~(~0ul << vidx_width) ;
        int shift = col_n * vidx_width;
        return ((col_cell_map & (mask << shift)) >> shift);
    }

    version_type& version_at_impl(int cell) {
        return vers_[cell];
    }

    void install_by_cell_impl(four_version_row *dst, const four_version_row *src, int cell) {
        switch (cell) {
        case 0:
            dst->f1 = src->f1;
            dst->f2 = src->f2;
            break;
        case 1:
            dst->f3 = src->f3;
            dst->f4 = src->f4;
            break;
        case 2:
            dst->f5 = src->f5;
            dst->f6 = src->f6;
            break;
        case 3:
            dst->f7 = src->f7;
            dst->f8 = src->f8;
            break;
        default:
            always_assert(false, "cell id out of bound\n");
            break;
        }
    }

private:
    version_type vers_[num_versions];
    static constexpr unsigned int vidx_width = 2u;
    static constexpr uint64_t col_cell_map = 64080ul;
};


template <typename VersImpl>
class VerSel<eight_version_row, VersImpl> : public VerSelBase<VerSel<eight_version_row, VersImpl>, VersImpl> {
public:
    typedef VersImpl version_type;
    static constexpr size_t num_versions = 8;

    explicit VerSel(type v) : vers_() { (void)v; }
    VerSel(type v, bool insert) : vers_() { (void)v; (void)insert; }

    static int map_impl(int col_n) {
        uint64_t mask = ~(~0ul << vidx_width) ;
        int shift = col_n * vidx_width;
        return ((col_cell_map & (mask << shift)) >> shift);
    }

    version_type& version_at_impl(int cell) {
        return vers_[cell];
    }

    void install_by_cell_impl(eight_version_row *dst, const eight_version_row *src, int cell) {
        switch (cell) {
        case 0:
            dst->f1 = src->f1;
            break;
        case 1:
            dst->f2 = src->f2;
            break;
        case 2:
            dst->f3 = src->f3;
            break;
        case 3:
            dst->f4 = src->f4;
            break;
        case 4:
            dst->f5 = src->f5;
            break;
        case 5:
            dst->f6 = src->f6;
            break;
        case 6:
            dst->f7 = src->f7;
            break;
        case 7:
            dst->f8 = src->f8;
            break;
        default:
            always_assert(false, "cell id out of bound\n");
            break;
        }
    }

private:
    version_type vers_[num_versions];
    static constexpr unsigned int vidx_width = 3u;
    static constexpr uint64_t col_cell_map = 16434824ul;
};


}; // namespace ver_sel
